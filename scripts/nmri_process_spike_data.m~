function [ subject ] = nmri_process_spike_data( subject, params )
%UNTITLED5 Summary of this function goes here
%   Detailed explanation goes here




% check the call
if (~exist('subject','var') ) 
 error('Need a valid subject struct or .m/.mat file to work with')
end

% call the subject and params include
nmri_include_read_ps


% check if we have dws_filt_dataset (this is the minimum)
if (~isfield(subject,'dws_filt_dataset') || ~exist(subject.dws_filt_dataset,'file'))
 error('Filtered and downsampled dataset not specified, run nmri_preproc first')
end

% check if we have the markers
if ~isfield(subject,'evt_timings_seconds') || ~isfield(subject,'evt_IDs')
 error('No markers/IDs found in subject struct / dws_filt dataset. Cannot work this way')
end 

% make our output path and dir
if (~isfield(subject,'evt_clean_dataset'))
 subject.evt_clean_dataset=fullfile(subject.analysis_dir,subject.id,'processed',['evt_clean_' subject.id '_' subject.exam_id '.mat']);
end

 %% Get the modality-specific analysis params
[ params ] = nmri_get_modality_params( params, subject.dtype );


%% check the cleaned version
if (exist(subject.evt_clean_dataset,'file'))
 load(subject.evt_clean_dataset,'data');   
else
 %% not found so process from dws_filt
 load(subject.dws_filt_dataset,'data');
 
 %% Now segment the data as per ID
 fsample=data.fsample;
 IDs=unique(subject.evt_IDs);
 pre = (params.EventsTOI*fsample);
 post = (params.EventsTOI*fsample);
 data_evt={};
 
 % loop over unique IDs
 for i=1:length(IDs)
  timings=subject.evt_timings_seconds(strcmp(subject.evt_IDs,IDs{i}))*fsample;
  % make a trial definition
  trl = [round(timings-pre) round(timings+post) -round(pre)*ones(length(timings),1)];
 
  % cutout these segments
  cfg     = [];
  cfg.trl = trl;
  data_evt{i}    = ft_redefinetrial(cfg,data);
 end
 % save some mem
 clear data
 subject.evt_uniqueIDs=IDs; 
 
 %% Now make channels consistant to resting-state analyis
 load(subject.clean_dataset,'data');
 cfg=[];
 cfg.channel=data.label;
 for i=1:length(IDs)
  data_evt{i}=ft_selectdata(cfg,data_evt{i});
 end
 clear data
 
 %% Now do some visual inspection
 for i=1:length(IDs)
  
  % make artificial sampleinfo - pseudo non-overlapping
  data_evt{i}.sampleinfo_bck=data_evt{i}.sampleinfo;
  counter=1;
  for s=1:length(data_evt{i}.trial)
   data_evt{i}.sampleinfo(s,:)=[counter counter+size(data_evt{1}.trial{1},2)-1];
   counter=counter+size(data_evt{1}.trial{1},2);
  end

  % now do visual inspection trial-by-trial
  h=msgbox({'Check each trial and mark artifact (drag box and fill with left click)','The whole trial will be discarded if within 500ms of spike (time 0sec).','All other artifacts/markings (e.g. other spikes that occur before or after the "active" one) or just removed.',['Note: Currently trial count = ' num2str(length(data_evt{i}.trial))],'Close window when done'},'Trial inspection');
  uiwait(h)
  cfg = [];
  cfg.viewmode = 'vertical';
  cfg.continuous = 'no';
  art = ft_databrowser(cfg,data_evt{i});
  art_bck=art;
 
  % first reject complete trials if within 500ms of spike
  disp('Reject completely if in critical period')
  art.artfctdef.reject='complete';
  art.artfctdef.crittoilim=[-0.5 0.5];
  data_evt{i} = ft_rejectartifact(art,data_evt{i});
 
  % now reject only partial - forming new trials possibly 
  disp('Reject the other markings partially')
  art=art_bck;
  art.artfctdef.reject='partial';
  art.artfctdef.minaccepttim=1; % minimum length of one second required 
  data_evt{i} = ft_rejectartifact(art,data_evt{i});
 
 
  % Now demean finally and re-reference if EEG
  if (strcmp(subject.dtype,'EEG'))
   cfg          = [];
   cfg.demean   = params.preproc_cfg.demean;
   cfg.reref      = 'yes';
   cfg.refchannel = 'all';
   cfg.vartrllength = 2;
   data_evt{i}        = ft_preprocessing(cfg,data_evt{i});
  end
 end
end

%% Load Electrodes if EEG
if (strcmp(subject.dtype,'EEG'))
 if (~isfield(subject,'electrodes_aligned') || ~exist(subject.electrodes_aligned,'file'))
  error('Have not found EEG electrodes - should be generated by the headmodel step')
 end
 load(subject.electrodes_aligned,'elec_aligned','elec_present','elec_missing')
end


%% Now do timelock
cfg                  = [];
cfg.covariance       = 'yes';
cfg.covariancewindow = [-inf -0.5]; % 3 s before the spike
cfg.vartrllength = 2;
cfg.keeptrials = 'yes';
spike_data           = ft_timelockanalysis(cfg, data_evt{1});
    

    load(subject.hdm_lead,'hdm','leadfield');
load(subject.suma_surface,'suma_all');


    cfg                    = [];
    cfg.method             = 'mne';
    cfg.grid               = leadfield;
    cfg.vol                = hdm;
    cfg.mne.prewhiten      = 'yes';
    cfg.mne.lambda         = 3;
    cfg.mne.scalesourcecov = 'yes';
    cfg.mne.keeptrials = 'yes';
    
     % for EEG need the electrodes
 if (strcmp(subject.dtype,'EEG'))
  cfg.elec            = elec_present;
 end
 
 spike_source           = ft_sourceanalysis(cfg,spike_data);
 

 % LCMV
   cfg                    = [];
    cfg.method             = 'lcmv';
    cfg.grid               = leadfield;
    cfg.vol                = hdm;
   
    
     % for EEG need the electrodes
 if (strcmp(subject.dtype,'EEG'))
  cfg.elec            = elec_present;
 end
  spike_source           = ft_sourceanalysis(cfg,spike_data);
 
% now plot
%0
nmri_plot_surface_suma(suma_all,spike_source.avg.pow(:,nearest(spike_source.time,0)),[])
% -0.1
nmri_plot_surface_suma(suma_all,spike_source.avg.pow(:,nearest(spike_source.time,-0.5)),[])
end 
 


