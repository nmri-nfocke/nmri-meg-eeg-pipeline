function [ subject ] = nmri_process_spike_data( subject, params )
%UNTITLED5 Summary of this function goes here
%   Detailed explanation goes here




% check the call
if (~exist('subject','var') ) 
 error('Need a valid subject struct or .m/.mat file to work with')
end

% call the subject and params include
nmri_include_read_ps


% check if we have dws_filt_dataset (this is the minimum)
if (~isfield(subject,'dws_filt_dataset') || ~exist(subject.dws_filt_dataset,'file'))
 error('Filtered and downsampled dataset not specified, run nmri_preproc first')
end

% check if we have the markers
if ~isfield(subject,'evt_timings_seconds') || ~isfield(subject,'evt_IDs')
 error('No markers/IDs found in subject struct / dws_filt dataset. Cannot work this way')
end 

% make our output path and dir
if (~isfield(subject,'evt_clean_dataset'))
 subject.evt_clean_dataset=fullfile(subject.analysis_dir,subject.id,'processed',['evt_clean_' subject.id '_' subject.exam_id '.mat']);
end

if (~isfield(subject,'electrodes_aligned'))
 subject.electrodes_aligned=fullfile(subject.analysis_dir,subject.id,'processed',['electrodes_aligned_' subject.id '_' subject.exam_id '.mat']);
end

 %% Get the modality-specific analysis params
[ params ] = nmri_get_modality_params( params, subject.dtype );


%% check the cleaned version
if (exist(subject.evt_clean_dataset,'file'))
 load(subject.evt_clean_dataset,'data');   
else
 %% not found so process from dws_filt
 load(subject.dws_filt_dataset,'data');
 
 %% Now segment the data as per ID
 fsample=data.fsample;
 IDs=unique(subject.evt_IDs);
 pre = (params.EventsTOI*fsample);
 post = (params.EventsTOI*fsample);
 data_evt={};
 
 % loop over unique IDs
 for i=1:length(IDs)
  timings=subject.evt_timings_seconds(strcmp(subject.evt_IDs,IDs{i}))*fsample;
  % make a trial definition
  trl = [round(timings-pre) round(timings+post) -round(pre)*ones(length(timings),1)];
 
  % cutout these segments
  cfg     = [];
  cfg.trl = trl;
  data_evt{i}    = ft_redefinetrial(cfg,data);
 end
 % save some mem
 clear data
 subject.evt_uniqueIDs=IDs; 
 
 %% Now make channels consistant to resting-state analyis
 load(subject.clean_dataset,'data');
 cfg=[];
 cfg.channel=data.label;
 for i=1:length(IDs)
  data_evt{i}=ft_selectdata(cfg,data_evt{i});
 end
 clear data
 
 %% Now do some visual inspection
 for i=1:length(IDs)
  
  % make artificial sampleinfo - pseudo non-overlapping
  data_evt{i}.sampleinfo_bck=data_evt{i}.sampleinfo;
  counter=1;
  for s=1:length(data_evt{i}.trial)
   data_evt{i}.sampleinfo(s,:)=[counter counter+size(data_evt{1}.trial{1},2)-1];
   counter=counter+size(data_evt{1}.trial{1},2);
  end

  % now do visual inspection trial-by-trial
  h=msgbox({['Event ID=' IDs{i}],'','Check each trial and mark artifacts (drag box and fill with left click)','The whole trial will be discarded if within 500ms of spike (time 0sec).','All other artifacts/markings (e.g. other spikes that occur before or after the "active" one) or just removed.',['Note: Currently trial count = ' num2str(length(data_evt{i}.trial))],'Close window when done'},'Trial inspection');
  uiwait(h)
  cfg = [];
  cfg.viewmode = 'vertical';
  cfg.continuous = 'no';
  art = ft_databrowser(cfg,data_evt{i});
  art_bck=art;
 
  % first reject complete trials if within 500ms of spike
  disp('Reject completely if in critical period')
  art.artfctdef.reject='complete';
  art.artfctdef.crittoilim=[-0.5 0.5];
  data_evt{i} = ft_rejectartifact(art,data_evt{i});
 
  % now reject only partial - forming new trials possibly 
  disp('Reject the other markings partially')
  art=art_bck;
  art.artfctdef.reject='partial';
  art.artfctdef.minaccepttim=1; % minimum length of one second required 
  data_evt{i} = ft_rejectartifact(art,data_evt{i});
 
 
  % Now demean finally and re-reference if EEG
  if (strcmp(subject.dtype,'EEG'))
   cfg          = [];
   cfg.demean   = params.preproc_cfg.demean;
   cfg.reref      = 'yes';
   cfg.refchannel = 'all';
   cfg.vartrllength = 2;
   data_evt{i}        = ft_preprocessing(cfg,data_evt{i});
  end
 end
 
 % now save
 save(subject.evt_clean_dataset,'data_evt','subject');  
end



%% Load Electrodes if EEG
if (strcmp(subject.dtype,'EEG'))
 if (~isfield(subject,'electrodes_aligned') || ~exist(subject.electrodes_aligned,'file'))
  error('Have not found EEG electrodes - should be generated by the headmodel step')
 end
 load(subject.electrodes_aligned,'elec_aligned','elec_present','elec_missing')
end


%% Now do timelock
cfg                  = [];
cfg.covariance       = 'yes';
cfg.covariancewindow = [-inf -2]; % Covariance will be estimated 2 s before the spike
cfg.vartrllength = 2;
cfg.keeptrials = 'no'; % cannot keep trials here - screws up the cov estimation for incomplete trials
timelock           = ft_timelockanalysis(cfg, data_evt{1});
    

    load(subject.hdm_lead,'hdm','leadfield');
load(subject.suma_surface,'suma_all');


    cfg                    = [];
    cfg.method             = 'mne';
    cfg.grid               = leadfield;
    cfg.vol                = hdm;
    cfg.mne.prewhiten      = 'yes';
    cfg.mne.lambda         = 3;
    cfg.mne.scalesourcecov = 'yes';
    cfg.mne.keeptrials = 'yes';
    
     % for EEG need the electrodes
 if (strcmp(subject.dtype,'EEG'))
  cfg.elec            = elec_present;
 end
 
 source_filters           = ft_sourceanalysis(cfg,timelock);
 

 % LCMV
   cfg                    = [];
    cfg.method             = 'lcmv';
    cfg.grid               = leadfield;
    cfg.vol                = hdm;
   cfg.lcmv.fixedori = 'yes';
   cfg.lcmv.keepfilter = 'yes';
   cfg.keeptrials = 'yes';
    
     % for EEG need the electrodes
 if (strcmp(subject.dtype,'EEG'))
  cfg.elec            = elec_present;
 end
  source_filters           = ft_sourceanalysis(cfg,timelock);
 
 % project trials timecourse
 data_source=data_evt{1};
 data_source.label = cellstr(num2str((1:sum(source_filters.inside))'));
 % loop over trials
 for ti=1:length(data_source.trial)
  fprintf('Projecting trial: %d/%d\n',ti,length(data_source.trial))
  data_source.trial{ti}=zeros(sum(source_filters.inside),size(data_evt{1}.trial{ti},2)); % make new trial
  sc_count=1;
  for si = 1:length(source_filters.inside)
   if ~isempty(source_filters.avg.filter{si})
    data_source.trial{ti}(sc_count,:)=source_filters.avg.filter{si}*data_evt{1}.trial{ti};
    sc_count=sc_count+1;
   end
  end 
  if (sc_count-1)~=sum(source_filters.inside)
   error('Did not reach requiered source count -- stopping here')
  end
 end
 
 % make a new timelock in source space
 cfg                  = [];
 cfg.covariance       = 'no';
 cfg.vartrllength = 1;
 timelock_source           = ft_timelockanalysis(cfg, data_source);
 
 pcfg=[];
 pcfg.per_hemi=1;
 pcfg.per_cortex=1;
 
 
 
 % plot raw
 all_val=reshape(data_source.avg,1,numel(data_source.avg));
 all_val(isnan(all_val))=[];
 pmean=mean(all_val);
 pmax=max(all_val);
 pmin=min(all_val);
 pmedian=median(all_val);
 piqr=iqr(all_val);
 pcfg.clim=[0 pmedian+(5*piqr)];
 pcfg.opathresh=pmedian+(2*piqr); 
 all_plots={};
 for toi=-1:0.2:1
  pcfg.output=sprintf('raw_t%.2f.png',toi);
  pcfg.title=sprintf('LCMV Raw @ %.2f sec',toi);
  f=data_source.avg(:,nearest(data_source.time,toi));
  f(isnan(f))=0;
  hFig=nmri_plot_surface_suma(suma_all,f,pcfg);
  close(hFig);
  all_plots=[all_plots {pcfg.output}];
 end
 output_all=sprintf('LCMV_Raw');
 cmd=['montage -gravity South -mode concatenate -tile x' num2str(length(all_plots)) ' -background white ' strjoin(all_plots,' ') ' ' output_all];
 system(cmd);
 system(['rm -f ' strjoin(all_plots,' ') ])
 
 % now calculate power
 cfg=[];
 cfg.method='mtmconvol';
 cfg.taper='hanning';
 cfg.foi=params.freqs;
% cfg.tapsmofrq = params.tapsmofrq; 
 cfg.toi=-0.2:0.05:0.4;
 cfg.t_ftimwin=ones(length(cfg.foi),1).*0.05; % 50ms window
 cfg.output='pow';
 cfg.pad = 'nextpow2';
 hann=ft_freqanalysis(cfg,data_source);
 
 
 % generate marker plots for all times
 all_markers={};
 for ti=1:(length(hann.time))
  % make a line marker for this time
  begsample=nearest(timelock.time,cfg.toi(1));
  endsample=nearest(timelock.time,cfg.toi(end));
  hFig=figure('Position',[0,0,250,250],'Visible','Off');
  set(hFig,'PaperUnits','inches','PaperPosition',[0 0 4 4])
  hold on
  plot(timelock.time(begsample:endsample),timelock.avg(:,begsample:endsample)); 
  pxl=[round(cfg.toi(1),2) round(cfg.toi(end),2)];
  xlim(pxl) % set xlimit
  pyl=ylim; % read ylimit (auto)
  line([hann.time(ti) hann.time(ti)],[pyl(1) pyl(2)],'Color','r','LineWidth',4)
  marker_plot=sprintf('marker_ti%d.png',ti);
  print(hFig,marker_plot,'-dpng','-r100')
  hold off
  close(hFig)
  all_markers=[all_markers {marker_plot}];
 end
 
 
 for fi=1:length(hann.freq)
  % scale for this frequency
  all_val=reshape(hann.powspctrm(:,fi,:),1,numel(hann.powspctrm(:,fi,:)));
  all_val(isnan(all_val))=[];
  pmedian=median(all_val);
  piqr=iqr(all_val);
  pcfg.clim=[0 pmedian+(5*piqr)];
  pcfg.opathresh=pmedian+(2*piqr); 
  all_plots={};
  for ti=1:(length(hann.time))
   pcfg.output=sprintf('spike_freq%d_ti%d.png',fi,ti);
   pcfg.title=sprintf('LCMV Power %s (%.1f Hz +/- %.1f) @ %.2f sec',params.freqsNames{fi},hann.freq(fi),params.tapsmofrq(fi),hann.time(ti));
   f=hann.powspctrm(:,fi,ti);
   f(isnan(f))=0;
   hFig=nmri_plot_surface_suma(suma_all,f,pcfg);
   close(hFig);
   all_plots=[all_plots {pcfg.output}];  
   % and merge marker left on plot
   marker_plot=sprintf('marker_ti%d.png',ti);
   cmd=['montage -gravity North -mode concatenate -tile 2x -background white ' marker_plot ' ' pcfg.output ' ' pcfg.output];
   system(cmd);
  end
  
  % now merge all
  output_all=sprintf('LCMV_Spike_Power_%s',params.freqsNames{fi});
  cmd=['montage -gravity North -mode concatenate -tile x' num2str(length(all_plots)) ' -background white ' strjoin(all_plots,' ') ' ' output_all];
  system(cmd);
  system(['rm -f ' strjoin(all_plots,' ') ]);
 end

 system(['rm -f ' strjoin(all_markers,' ') ]);
   
 

end 
 





